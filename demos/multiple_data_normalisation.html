<!doctype html>
<html>

<head>
    <meta charset="utf-8">
    <title>normalisation with multiple datasets</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <link rel="stylesheet" href="../dist/uPlot.min.css">
</head>

<body>
    <script src="../dist/uPlot.iife.js"></script>
    <script>
        // "null" -> there is a gap -> "no valide value for this curve has logged"
        // "undefined" -> will used by Normalisation to say: "There is no value for this curve!"
        const dataset01_s_blue = [
            { time: 0, value: 1 },
            { time: 4, value: 0 },
            { time: 6, value: 1 }
        ]
        const dataset02_s_red = [
            { time: 0, value: null },
            { time: 1, value: null },
            { time: 2, value: 3 },
            { time: 3, value: 4 },
            { time: 4, value: 5 },
            { time: 5, value: null },
            { time: 6, value: 3 },
            { time: 7, value: 2 },
            { time: 8, value: 1 },
            { time: 9, value: 0 }
        ]
        const dataset03_l_green = [
            { time: 1, value: 4.90 },
            { time: 8, value: 1.55 }
        ]
        const dataset04_l_yellow = [
            { time: 0, value: 1.11 },
            { time: 5, value: null },
            { time: 9, value: 4.44 }
        ]
        const dataset05_sin = [
            { time: 0, value: Math.sin(0 * (Math.PI / 180)) * 5 },
            { time: 1, value: Math.sin(10 * (Math.PI / 180)) * 5 },
            { time: 3, value: Math.sin(30 * (Math.PI / 180)) * 5 },
            { time: 4, value: null },
            { time: 5, value: Math.sin(50 * (Math.PI / 180)) * 5 },
            { time: 7, value: Math.sin(70 * (Math.PI / 180)) * 5 },
            { time: 8, value: Math.sin(80 * (Math.PI / 180)) * 5 },
            { time: 9, value: Math.sin(90 * (Math.PI / 180)) * 5 }
        ]

        class Normalisation {
            /** 
             * number of datasets 
             */
            seriesCount = 0

            /** 
             * all datasets
             * { [key: number]: Array<number | null | undefined> } 
             */
            dataHolder = []

            /**
             * add a dataset and normalisation with all other datasets
             */
            add(set) {
                const serieNr = ++this.seriesCount

                // "undefined" means there is no valide value for this point
                if (this.seriesCount > 1) {
                    // normalisation of existing datasets
                    Object.values(this.dataHolder).forEach((valuesAtTime) => {
                        if (valuesAtTime.length !== this.seriesCount) {
                            valuesAtTime.splice(serieNr - 1, 0, undefined)
                        }
                    })
                }
                set.forEach((p) => {
                    const timeToDraw = p.time
                    if (this.dataHolder[timeToDraw] === undefined) {
                        this.dataHolder[timeToDraw] = []
                        for (let nr = 0; nr < this.seriesCount; nr++) {
                            this.dataHolder[timeToDraw][nr] = undefined
                        }
                    }
                    this.dataHolder[timeToDraw][serieNr - 1] = p.value
                })
            }

            /**
             * generate Dataset for uPlot
             */
            map() {
                /** uPlot.AlignedData */
                const data = [[]]
                const timeserie = data[0]
                Object.entries(this.dataHolder)
                    .sort()
                    .forEach(([time, valuesAtTime], i) => {
                        const timestamp = Number(time)
                        timeserie[i] = timestamp
                        valuesAtTime.forEach((valueAtTime, nr) => {
                            const dataSetNr = nr + 1
                            if (!data[dataSetNr]) {
                                data[dataSetNr] = []
                            }
                            data[dataSetNr][i] = valueAtTime
                        })
                    })
                return data
            }
        }

        const opts = {
            title: "Lines and stepps -> normalisation of datasets",
            width: 800,
            height: 400,
            legend: {
                // to calculate you might have to specific "value"/"values"/"gaps" for some series
                show: false
            },
            cursor: {
                // to calculate you might have to specific "value"/"values"/"gaps" for some series
                show: false
            },
            scales: {
                x: {
                    time: false,
                }
            },
            series: [
                {},
                {
                    label: "on/off",
                    stroke: "blue",
                    fill: "blue",
                    alpha: 0.25,
                    width: 2,
                    paths: uPlot.paths.stepped({ align: 1 }),
                },
                {
                    label: "[0..5]",
                    stroke: "red",
                    fill: "red",
                    alpha: 0.25,
                    width: 2,
                    paths: uPlot.paths.stepped({ align: 1 }),
                },
                {
                    label: "dataset03",
                    stroke: "green",
                    width: 2,
                },
                {
                    label: "dataset04",
                    stroke: "yellow",
                    width: 2,
                },
                {
                    label: "dataset05 sin",
                    stroke: "black",
                    width: 2,
                },
            ],
        };

        const dataHolder = new Normalisation()
        
        performance.mark('map_start');
        dataHolder.add(dataset01_s_blue)
        dataHolder.add(dataset02_s_red)
        dataHolder.add(dataset03_l_green)
        dataHolder.add(dataset04_l_yellow)
        dataHolder.add(dataset05_sin)
        const data = dataHolder.map()
        performance.mark('map_end');

        performance.mark('join_start');
        const data01 = [dataset01_s_blue.map(v => v.time), dataset01_s_blue.map(v => v.value)]
        const data02 = [dataset02_s_red.map(v => v.time), dataset02_s_red.map(v => v.value)]
        const data03 = [dataset03_l_green.map(v => v.time), dataset03_l_green.map(v => v.value)]
        const data04 = [dataset04_l_yellow.map(v => v.time), dataset04_l_yellow.map(v => v.value)]
        const data05 = [dataset05_sin.map(v => v.time), dataset05_sin.map(v => v.value)]
        const dataJoined = uPlot.join([data01, data02, data03, data04, data05])
        performance.mark('join_end');
        const r_my = performance.measure("measure map", 'map_start', 'map_end');
        const r_join = performance.measure("measure join", 'join_start', 'join_end');
        console.log(r_my, r_join, r_my.duration < r_join.duration ? 'map never wins' : 'join is always faster');

        const plot = new uPlot(opts, data, document.body);

    </script>
</body>

</html>